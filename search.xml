<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2020%2F01%2F19%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[多线程初探]]></title>
    <url>%2F2020%2F01%2F03%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[什么是线程？与进程又是什么关系？我们为什么需要多线程？下列是维基百科对线程和进程的定义↓ 线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。 进程（英语：process），是指计算机中已运行的程序。进程曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若干进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步（平行）的方式独立运行。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机体系结构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。 我们如何去理解进程和线程几次总结发现都没有这位朋友赘述的易懂生动，下列为引用↓ 做个简单的比喻：进程=火车，线程=车厢 - 线程在进程下行进（单纯的车厢无法运行 - 一个进程可以包含多个线程（一辆火车可以有多个车厢）不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘） - 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易） - 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢） - 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间） －&quot;互斥锁&quot;进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量” 作者：biaodianfu 链接：https://www.zhihu.com/question/25532384/answer/411179772 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 为何需要多线程？这里为计算阶乘的无多线程程序↓(其实编写多线程的例子最好是IO密集型应用，这里计算阶乘的计算属于CPU密集型应用，如果没有人为的加上一些无意义循环，几乎看不到效果。且多线程用在正常的CPU密集型应用(它多半是很快的)还多半会降低性能。) 12345678910111213141516171819202122232425262728293031323334 long t0 = System.currentTimeMillis();//按照顺序依次执行4次循环1000次的calculate(10000) for (int i = 0; i &lt; 1000; i++) &#123; calculateFactorial(10000); &#125; for (int i = 0; i &lt; 1000; i++) &#123; calculateFactorial(10000); &#125; for (int i = 0; i &lt; 1000; i++) &#123; calculateFactorial(10000); &#125; for (int i = 0; i &lt; 1000; i++) &#123; calculateFactorial(10000); &#125; long t1 = System.currentTimeMillis(); System.out.println("耗时为" + (t1 - t0) + "ms"); &#125; private static long calculateFactorial(long N) &#123; if (N &lt; 0) &#123; return -1;//传入的数据不合法 &#125; if (N == 0) &#123; return 1; &#125; else if (N == 1) &#123;//递归结束的条件 return 1; &#125; else &#123; return N * calculateFactorial(N - 1); &#125; &#125; 测试结果普遍在 150ms 以上(反复测试可能还会溢出报错) 以下采用的是多线程版↓ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859long t0 = System.currentTimeMillis(); //这里开启四个线程，同时且无须的执行4个calculateFactorial方法new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; calculateFactorial(10000); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; calculateFactorial(10000); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; calculateFactorial(10000); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; calculateFactorial(10000); &#125; &#125; &#125;).start(); long t1 = System.currentTimeMillis(); System.out.println("耗时为" + (t1 - t0) + "ms"); &#125; private static long calculateFactorial(long N) &#123; if (N &lt; 0) &#123; return -1;//传入的数据不合法 &#125; if (N == 0) &#123; return 1; &#125; else if (N == 1) &#123;//递归结束的条件 return 1; &#125; else &#123; return N * calculateFactorial(N - 1); &#125; &#125; 测试结果普遍在 90ms 以下（效果显著！） 记住，多线程要能够成立你必须要保证有多个工人，只有一个工人你派发了两分任务也只是一个人做。还有，线程thread被创建出来并不会做功，你必须要给它下达start()或run()方法才行。 多线程会带来什么问题？如何去避免？多线程会带来以下三种问题 原子性问题 可见性问题 有序性问题 以下为原子性问题&amp;有序性问题的结合↓ 123456789101112131415161718192021 private static int num = 0; public static void main(String[] args) &#123; //循环一千次，new一个线程对类变量num进行操作↓ for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; add(); &#125; &#125;).start(); &#125; &#125; private static void add() &#123; num++; System.out.println("num="+ num); &#125; 你会得到一列很匪夷所思的打印，可能同一个数打印了两次，可能过程中一些数字漏了，可能还超过了100…….这是因为计算机在无序的且来回切换线程进行作业的，但自增本身是一个非原子性操作，并不是一步到位，这就让多线程变得很危险。 解决方案:对类变量添加 volatile 修饰符(这并不是百试百灵，多线程真的很诡异。。) 总结没啥说的，查阅了一下关于线程的相关试题，几乎都是关于锁和线程安全还有基于线程源码解读来解决实际问题三方面，自己却还没有进入到这一阶段。加油！]]></content>
      <categories>
        <category>后端方向</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A man with the tool and his spirit]]></title>
    <url>%2F2019%2F11%2F09%2FA-man-with-the-tool-and-his-spirit%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Since our father (I mean the ancestor) was coming to this land. A desperate situation for them, humans have been hunted by predators(these giant beasts), but they still alive. Why? Because they learned to stand as one and made the weapon against the predators. After that, there is no more enemy can fight with them when they discovered the fire and created the spear. In the end, our father conquests any land which they are crossing.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Honestly, the beast has many body advantages. Felids have the supervision that they can be watching in the night, even without light. The panther can maintain high speed on the ground of about one hundred kilometers per hour. The crocodile has the most powerful bite in the world, crash prey’s bone that like chocolate. What a great gift they have! But just like the old saying, Gift also means curse. The night vision also brings myopia, and the super speed also brings the short-lived. The crocodile’s bite makes it a clumsy body to evade the crisis.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What about humans? You may ask. Okay, everything in the human body is moderate, but we have the secret weapon, tool. The tool is the greatest invention in human history. We have gone through many crises and questions with the help of this friend. Okay, what’s the tool. You need it, it comes. You don’t need it, it leaves.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;But this is not enough if our human wants to keep our dominance in the earth. Because the tool is not the talent, it’s not from our body, and they could disappear. We are a weakness when we leave the tool. The spirit is the only advantage that we have to get through the challenge. Let me illustrate, The long march of the Red Army. It has not played a secondary role in human history. Contrary, it’s just as pivotal as the tool that we mentioned.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We still cannot escape from the parameter of the biology，nomatter how great we claim to be. We can help someone, but also can hurt someone, the lion could be dangerous, but so what? Imagining the human’s war, the blade, the gun, the biochemistry weapon, the nuclear weapon…., thousand and millions of innocent people will die. Sometimes, we humans are our own worst nightmare. Will power could help us to overcome the despair when we have nothing and stop us from becoming a demon when we do the bad things, just like Adolf Hitler. Spirit is always there for us and telling. Who we are and what we should do as a human.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唯有情深似海亦无边，任凭云散风吹去]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList.java初探]]></title>
    <url>%2F2019%2F10%2F18%2FArrayList-java%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[前言妹有前言 什么是Array？什么是ArrayList？我们该用哪个？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array是一个很常见的数据结构，很多语言都内置了Array。声明一个Array的同时就必须要进行实例化(初始化)也就是确定其Array长度，它只能存储同一数据类型的数据。 12345//声明并初始化Arrayint[] a = new int[10];int b[] = &#123;1,2,3,...&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList可以说是Array的企业版(haha)，它也是常见的数据结构。不需要直接声明后立即初始化，长度是根据需要而改变的。它可以存放不同类型的数据，但它存储的并不是int,float,double…，而是Integer,Float,Double…(但JAVA中存在自动装箱，所以并不用担心) 12345//声明并初始化ArrayList(并不需要同时进行)ArrayList al = new ArrayList();al.add(10,20,30,40,...); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array的性能是要优于ArrayList的，但因为数组在存储数据时是按顺序存储的，存储数据的内存也是连续的，所以它的特点就是寻址读取数据比较容易，插入和删除是比较困难的。加上Array只能存储同一种数据类型的数据且长度是固定，so,当能确定长度且数据类型一致的时候我们可以使用Array,其他时候则使用ArrayList。 ArrayList related properties123456789101112131415161718192021222324252627282930313233343536373839//ArrayList序列号，用于判断序列化文件是否已经失效 private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. *///ArrayList初始容量为10 private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. *///指定该ArrayList容量为0时，返回该空数组。 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. *///一个空array实例，如果你调用的是无参的Constructor时，返回的就是该array(默认返回！) private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. *///为什么说ArrayList是array的企业版，其实ArrayList就是把array存储在内，并提供了一些对array进行操作的方法，elementData就是我们ArrayList的容器。elemntdata也叫数组缓冲区。 transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial *///ArrayList世纪存储的数据数量 private int size; ArrayList Constructors1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative *///创建一个具有初始容量的空list public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; //大于零就创建一个基于initialCapacity大小的array this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; //等于零就是创建一个空array this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; //非法检测 throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. *///创建一个空ArrayList,长度为0.当元素第一次被add时，扩容至默认容量10 public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null *///创建一个包含Collection的ArrayList，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; ArrayList add()ArrayList在每一次添加数据时，都会执行ensureCapacityInternal()检查是否超出数组容 量 这里的扩容有许多细节可以详述，我们留到下一篇博文。123456789101112131415161718192021222324252627 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) *///添加指定的元素到ArrayList，位于位置最后。 public boolean add(E e) &#123; // 只有当size+1 &gt; 数组.length时才会执行扩容 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; //通过下标赋值 return true; &#125;//将指定的元素插入此ArrayList中的指定位置。 public void add(int index, E element) &#123; rangeCheckForAdd(index);//检查形式参数index是否合法。 ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()将index下标到末尾的数据右移一位↓ //[1,2,3,4,5,6,7,0,0,0]① //[1,2,2,3,4,5,6,7,0,0]② System.arraycopy(elementData, index, elementData, index + 1, size - index); //[1,x,2,3,4,5,6,7,0,0]③ x为element elementData[index] = element; size++; &#125; ArrayList Remove()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; *///将指定的元素删除 public E remove(int index) &#123; rangeCheck(index);//检查形式参数index是否合法 modCount++; E oldValue = elementData(index); //需要删除的元素 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //整个左移numMoved个下标单位 elementData[--size] = null; // clear to let GC do its work(让最后一个下标元素为空) return oldValue; &#125; /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element *///删除在ArrayList中首次出现的元素 public boolean remove(Object o) &#123; if (o == null) &#123; //由于ArrayList一样可以存储对象，所以还要进行null值判断 for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); // fastRemove()进行删除 return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index);// fastRemove()进行删除 return true; &#125; &#125; return false; &#125; /* * Private remove method that skips bounds checking and does not * return the value removed. *///调用arrayCopy()进行左移并最后一位元素进行留空 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * Removes from this list all of the elements whose index is between * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. * Shifts any succeeding elements to the left (reduces their index). * This call shortens the list by &#123;@code (toIndex - fromIndex)&#125; elements. * (If &#123;@code toIndex==fromIndex&#125;, this operation has no effect.) * * @throws IndexOutOfBoundsException if &#123;@code fromIndex&#125; or * &#123;@code toIndex&#125; is out of range * (&#123;@code fromIndex &lt; 0 || * fromIndex &gt;= size() || * toIndex &gt; size() || * toIndex &lt; fromIndex&#125;) *///删除从索引头fromIndex(包括)到toIndex(不包括)之间的元素 protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; //被删除的索引范围后的元素个数 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); //左移numMoved个单位 // clear to let GC do its work int newSize = size - (toIndex-fromIndex); //新array的长度 for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; //原本的下标元素置为null，好让JVM的垃圾回收机制干活 &#125; size = newSize; &#125; ArrayList set()1234567891011121314151617 /** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; *///用指定的元素替换相应下标的元素 public E set(int index, E element) &#123; rangeCheck(index);//检查形式参数index是否合法 //记录被替换的oldValue E oldValue = elementData(index); elementData[index] = element; //实现替换 return oldValue; //返回oldValue &#125; 为什么这里要返回一个oldValue?没什么，只是List接口给set方法的一个API设计而已。set方法严格遵守了这个约定。ps:感谢ber哥 ArrayList get()1234567891011121314 /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; *///返回在ArrayList中指定的元素 public E get(int index) &#123; rangeCheck(index);//检查形式参数index是否合法 return elementData(index); &#125; 最后&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过阅读ArrayList的源码后才发现，JDK设计的精妙。就像扩容机制一样，保证要存多少个元素，就只分配多少空间资源，保证空间资源不被浪费。这应该只是冰山一角。。。。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;额哈哈哈哈哈]]></content>
      <categories>
        <category>后端方向</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven and Classpath Hell]]></title>
    <url>%2F2019%2F09%2F28%2FMaven-and-Classpath-Hell%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前其实一直在用到Maven，但却没有怎么下功夫了解。但了解Maven还是非常有必要的。我一直很认同ber哥的一句话。 强大的IDE会割裂你和这些底层的运作。但你还是要了解这些底层运行的原理，因为总会遇到各种各样的问题让你不得不和这些底层打交道，对于工程师来说，生疏的表现是不合适的。了解这些细节，有助于你解决问题。工作就是在解决各种各样的问题。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过了解Maven所为我们做的，我们可以更深刻的理解整个JAVA世界的历史变革，对我们现在使用的一切有一定认知性。虽然不能讲得很深，但也能大致对Maven有一个感性的认识了。 什么是Maven? 什么是包？？？？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，Maven是一个包管理工具，也有人叫它项目管理工具。但此包非彼包，并不是初学JAVA时接触的那个Package包。那到底是什么包？我们不妨先引入一个概念。JVM的运行机制 JVM的工作只有一个: 执行这个类的字节码，过程中若碰到了新的类，加载它。(循环往复直到把事情做完) 那么，它是如何找到这些类的呢？我们知道，命令行中的那些可执行程序是在哪儿找到的呢，答案是在当前的PATH环境变量中找到的。相应的，我们找类也有一个路径，叫Classpath(类路径)， 和命令行业寻找可执行程序一样。JVM会挨个在PATH里面找，是压缩包就解压来找(这是全自动的)，文件夹就直接开找，找不到就下一个,找到为止。让我们随便看一个JAVA小案例的Classpath。 1-classpath "C:\Program Files\Java\jdk1.8.0_221\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_221\jre\lib\rt.jar;F:\shape-polymorphism\target\classes" com.github.hcsp.polymorphism.Main 由于存在包依赖关系，如果是真正的项目，这个Classpath会长得超出显示限制。。。。 类的全限定类名(目录层级)确定了一个类包就是把许多类放在一起打的压缩包啊!jar包就是一堆类的集合 介绍完包了之后，需要说的是，我们知道JVM懂得看到了方法去找类，找类也就是在找包(通过Classpath)，但包并不会凭空出来，很多第三方包都需要我们Down到项目中，添加到Classpath中，这也是Maven诞生的主要原因,包管理的本质就是告诉JVM如何找到所需的第三⽅类库。 开发过程更爽!生产出来的软件更棒! 让我们看一看没有Maven之前的年代，JAVA是如何走过来的。 蛮荒时代这个时候，全世界的JAVA工程师还没有形成包管理这样的概念， 一个一个手写命令进行编译运行，just like that1javac -cp ./commons-lang3-3.9.jar StringIsBlank.java 想象一下这里需要不仅仅是一个包，而是上面成千上百个。。。真正的编程到昏厥。苦不堪言(如果以现在的眼光看的话，无论什么情况当事人一般都会觉得还行哈哈哈哈哈哈哈哈哈哈) 启蒙时代Apache Ant 提出了XML配置文件来规范化所谓包管理，制定变异的源代码目录，依赖的JAR包，输出目录等。虽说有了点规范的意思，但还是跳不过一个一个手动下载的命，也没有解决JVM傻呆呆的处理重名JAR包的问题。(Classpath hell),且大家的编写各不相同，配置并不通用。你写你的libs，我写的library，他写他的依赖jar包文件夹，她写她的输出目录。大家经常拿Ant 和 Maven 作比较，现在Ant似乎不行了，大家就拿Gradle和 Maven 作比较。 由此可见Maven还是很坚挺的 :) Maven时代Maven是一款跨时代的包管理工具，它使用了一套相当先进的项目结构及约定征服了全世界的工程师。首先它存在一个中央仓库，还制定了一些规则，让全世界的工程师不用再一个一个手写命令行编译运行，而是变为了导包。我们只需要在pom.xml文件按照相应的约定格式导入即可，就下载到了你的本地仓库。下载的第三方包放在这里进行缓存。它还会把你下载的第三方包所以来的其他包一并下载进来。 中央仓库的构建，对于包管理方面按照约定为所有的包编号，⽅便检索 1234567&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.4.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Maven这一严谨的规定折服了所有的工程师，以至于后面诞生的包管理工具相关规定也有这样的影子。除此之外，Maven还解决了一个JAVA历史性难题。Classpath Hell (类路径地狱)。 什么是Classpath Hell，也就是包冲突？如果你的classpath或项目里面不幸地引入了两个版本不一样，但同名的jar包。就是噩梦的开始，JVM可不会想人一样会斟酌选择，它只会找到哪个用哪个。用不到这个包自然不报错，它会让你错误地认为一切顺风顺水，然而，它也会在某一天毫无征兆的暴毙，然后你只得大半天赶到开始接受地狱般的bug挑战。 常见的包冲突的一些报错： AbstractMethodError NoClassDefFoundError ClassNotFoundException LinkageError 包管理有一个原则：绝对不允许最终的classpath出现同名不同版本的JAR包。 只有能够得知包冲突，才能解决。 maven 是 如何得知 两个包冲突呢 因为maven把这些包按照名字格式把它们归类起来了。 依赖冲突的解决：最近的胜出 这个机制让maven能够解决绝大多数的情况，但在现实生活中，我们还是会遇到需要亲自手动去解决的情况。为什么？因为mvn解决掉的是0.2版本，保留0.1版本。但我们要用的确是更新版本的0.2版本！！！！ 你可以打开ide点击maven窗口，用肉眼目测整个项目的包依赖关系。 也可以在终端输入1mvn dependency:tree 来观察。 如何手动解决？ 我们手动介入让我想要的版本的jar包离的最近，从让它在JVM的包冲突的比较中胜出，自然JVM用的就是这个包。 通过exclusions声明强行干掉子依赖 如果想让ide来帮助你的话，你可能需要maven-helper插件，当然非人的调试还是可能出问题。 拓展一下，如果是这样呢？ A-&gt;B-&gt;C:0.1 D-&gt;E-&gt;C:0.2 谁赢，答案是0.1版本获胜，maven还是会选择前面的那一个。 maven总是会选择一个，因为绝对不允许最终的classpath出现同名不同版本的JAR包。 那Maven还有一个关键属性 scope ，它有什么用呢？ 其实很简单，它的作用就是 让依赖 可以隔离化。换言之就是让 依赖不是全盘默认，而是可以人为的决定这个是否可以依赖。 scope的常用属性为 compile test provided test: 只在测试代码中可以拿到依赖包 compile: 在测试和生产环境中都可以拿到依赖包 provided: 在编译的时候可以拿到，在运行时就拿不到了 Maven的伟大之处——它不仅仅是项目管理工具！Maven项目构建，版本控制，库依赖三大特性。若想真正了解Maven 建议阅读 Maven实战]]></content>
      <categories>
        <category>后端方向</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA的装箱类型初探]]></title>
    <url>%2F2019%2F09%2F22%2FJAVA%E7%9A%84%E8%A3%85%E7%AE%B1%E7%B1%BB%E5%9E%8B%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[PS:三天后朱健迎来他的第一场面试，希望他能得到他想要的结果。好了不说他了，我们干我们的。 什么是装箱类？我们为什么要装箱？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们知道，JAVA存在8中基本类型，4中引用类型。 byte short int long float double char boolean StrongReference SoftReference WeakReference PhantomReference &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象(也就是引用数据类型)相对于基本数据类型更加高级，它不但可以存储数据还可以存储方法还可以继承还可以封装………那强调万物皆对象的JAVA，为什么还需要int，float这些基本类型呢。下面这段话是在论坛看到的，说得真的很好，插一下。 按理说C#被设计成一种完全面向对象的语言。因此，包括数字、字符、日期、布尔值等等在内的一切，都是对象。似乎只需要一种方式来对待这些对象就可以了。 但是C#不是只停留在学院中和理想中，它必须为性能而妥协，我们知道，对于CPU来说，处理一个完整的对象，需要很多的指令，对于内存来说，又需要很多的内存。如果连整数都是对象，那么性能自然很低。C#于是使用了一种机制，使得这些基本类型在一般的编程中被当作非对象的简单类型处理，在另一些场合，又允许它们被视作是一个对象。这种机制就是装箱和拆箱。 装箱后的对象看上去和一个对象一样，拥有方法，可以当作object处理，拆箱后的变量，看上去又如同C语言中的那些变量、结构体一样，可以直接参与运算和处理。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JAVA也是一样的，一句话概括装箱和拆箱 自动根据数值类型创建对应的对象，此为装箱(boxing) 自动根据装箱(类型)转变为基本类型，此为拆箱(unBoxing) 基本类型 --- 装箱类型 int --- Integer short --- Short long --- Long double --- Double float --- Float boolean --- Boolean byte --- Byte char --- Character 如何编写装箱类型,它怎么用的。Integer i = 1; //自动装箱 int j = i; //自动拆箱 public void argAutoBoxing(Integer i) { } argAutoBoxing(1); //自动装箱 public void argAutoUnBoxing(int i) { } argAutoUnBoxing(new Integer(1)); //自动拆箱 //我们将只有存储作用的基本类型变为装箱类型的对象后，可以使用背后的`方法`相互转化 //这个用法非常常见，也是主要功能 String year = &quot;2018&quot;; int i = Integer.parseInt(year); System.out.println(i/2); 注意！Integer i = new Integer(xx)和Integer i = xx是不一样的，这个后面再提及 什么时候使用int，什么时候用Integer?我们知道的是，在堆内存创建对象的消耗比起使用栈内存是要大的 ，如果是在数据量较大或是循环次数较多的情况下,对性能的影响是非常大的。若非是特殊需求，一般使用基本类型而不是装箱类型。 1234567891011 Integer sum = 0; for(int i =0;i&lt;=2000;i++)&#123; sum += i; &#125;这里的 sum += i 等价为 sum = sum + i;JVM检测到右边为`表达式`,则自动触发拆箱 sum = sum.intValue() + i;JVM检测到左边为`装箱类`，则自动触发装箱 Integer sum = new Integer(result); sum为Integer类型，在上面的循环中会创建2000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题 拆装箱的内部原理是什么？我们上面提到的自动拆装箱为例123456Integer i = 1; //自动装箱 JVM调用Integer类的valueOf()方法 int j = i; //自动拆箱 JVM调用Integer类的intValue()方法 //其他类型类推 让我们看看valueOf()和intValue()两个方法的具体实现 1234567891011121314151617181920/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 通过valueOf()方法创建Integer对象的时候，如果数值在符合条件，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。 12345678/** * Returns the value of this &#123;@code Integer&#125; as an * &#123;@code int&#125;. */public int intValue() &#123; return value;&#125; 通过intValue()方法将参数转化为基本类型并返回。 练习&amp;拓展下面是搜集的一些关于装箱类的一些基础面试题，让我们通过这些试题来练习一下也拓展之前并没有提及的知识点。 友情提示 对于两边都是包装类型的比较==比较的是引用，equals比较的是值。 对于两边有一边是表达式（包含算数运算）则==比较的是数值（自动触发拆箱过程），对于包装类型equals方法不会进行类型转换。 1.12345678910111213public class Main &#123; public static void main(String[] args) &#123; Integer a = 100; Integer b = 100; Integer c = 200; Integer d = 200; System.out.println(a==b); System.out.println(c==d); &#125;&#125; 这里得到的输出应是 true 和 false ，通过观察上面提到的装箱发放valueOf()方法，并再仔细观看里面嵌入的另一个关键方法IntegerCache()我们发现，可以进一步将进一步解读ValueOf()为 valueOf方法，参数如果是-128~127之间的值会直接返回内部缓存池中已经存在对象的引用，参数是其他范围值则返回新建对象 2.12345678910111213public class Main &#123; public static void main(String[] args) &#123; Double a = 100.0; Double b = 100.0; Double c = 200.0; Double d = 200.0; System.out.println(a==b); System.out.println(c==d); &#125;&#125; 我们会发现得到的输出都是false，是因为不同的数据类型有不同的valueOf()实现方式。通过查阅文档和编写实验，可以得出一个结论: 对于Integer、Short、Byte、Character、Long类型的valueOf方法，参数如果是-128~127之间的值会直接返回内部缓存池中已经存在对象的引用，参数是其他范围值则返回新建对象； 而Double、Float类型与Integer类型类似，一样会调用Double、Float的valueOf方法，但是不管传入的参数值是多少都会new一个对象来表达该数值，因为在某个范围内的整型数值的个数是有限的，而浮点数却不是。 3.123Boolean i = null;boolean j = i; 这里，会得到一个NullPointerException异常。虽然自动拆装箱非常方便，但千万不要同等对待了。 对象Boolean里有 true false null ，基本类型boolean里可没有null。 4.123456public static void main(String[] args) &#123; Integer i =new Integer(12); Integer j = 12; System.out.println(i == j);&#125; 照理来说，通过练习1我们应该推测这里得到的输出应该是true，12并没有超出缓存范围。但通过实践得到的输出确是false。这是为什么呢？ 因为，new Integer(xxx)这种创建对象的方法不是自动装箱，没有用到cache。两个对象自然指向的不是一个区域的值。 5.12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; Long h = 2L; System.out.println(c==d); System.out.println(e==f); System.out.println(c==(a+b)); System.out.println(c.equals(a+b)); System.out.println(g==(a+b)); System.out.println(g.equals(a+b)); System.out.println(g.equals(a+h)); &#125;&#125; 这个题我就不讲解，结合前面的知识点来练习就可以得到相应的正确输出，也可以真正了解到==和equals的区别。 装箱类的应用十分广泛，基础的知识掌握是必须的。 总结，是一件快乐的事。 下周循环！]]></content>
      <categories>
        <category>后端方向</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 GitHub Pages 预览 HTML]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-GitHub-Pages-%E9%A2%84%E8%A7%88-HTML%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多时候，我们在打开一个web项目想做的第一件事，并不是查看CSS样式，也不是JS脚本逻辑，更不是背后的 后台交互逻辑。我们只是想很直观的看到整个web页面的呈现。但问题就来了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通常的做法是，选择 git clone来将整个仓库down到本机，再打开项目进行浏览。但能否有更简洁的方法能够直接观看页面效果呢。这个时候GitHub内置的GitHub Pages就很好的满足了这一点。(若是要编写页面实时查看效果还是建议clone到本地进行操作) GitHub Pages 可以托管网页 操作过程 首先我们打开一个创建并上传了的项目，并点击Settings 下划找到GitHub Pages部分，将Source选项里的None，更改为master branch。 随后你就会得到这个一个网址，点击即可进入观看到项目的HTML文件 结语 是不是非常方便？越是去了解github就越是体会到这个平台的精妙。其实到了后面我关注到的重点并不是简便的查看页面效果。而是Github Pages可以搭建博客，绑定域名，是基于什么原理的呢？？ 这里现将答案附上，但无奈水平问题只能读个一知半解。待以后复习回顾之。 作者：Rainux Luo 链接：https://www.zhihu.com/question/26609475/answer/37395382 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1. GitHub/GitCafe Pages 服务会为每个包含 gh-pages/gitcafe-pages 分支的项目创建包含该分支内容的 wwwroot 目录，这些目录符合特定命名规则。 2. Web server 被配置为使用 name-based virtual server 方式 publish 所有以上 wwwroot 目录。这些 virtual server 的域名就包括大家熟知的 {username}.http://gitcafe.io 和 Pages 用户绑定的任意域名。 3. Pages 用户将绑定的域名通过 A 记录或 CNAME 记录（具体哪个并不重要，CNAME 记录的好处只在于 GitHub/GitCafe Pages 服务器变更 IP 时用户无需修改域名指向）将绑定的域名指向以上 Web server 所在主机，我们所有人就可以像访问任何普通静态网站一样访问到 Pages 站点。至于 blog，原本不必是 GitHub/GitCafe Pages 服务的功能。以上原理告诉我们 GitHub/GitCafe Pages 可以将任意静态页面内容 host 为一个网站，所以我们可以使用 Jeklly、Ocotopress、Hexo 等任何输出静态页面内容的工具生成 blog 或是普通网站。只是因为这些工具中 Jeklly 最流行且简洁灵活，GitHub/GitCafe Pages 选择了直接在服务器端支持它，在 publish 前对 gh-pages/gitcafe-pages 分支内容执行 Jeklly build。 神奇的GitHub Pages]]></content>
      <categories>
        <category>前端方面</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backstreet booooooooys]]></title>
    <url>%2F2019%2F09%2F09%2FBackstreet-booooooooys%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;It’s my honor to meet you, Backstreet boys.after all these years passed, you guys are still can be singing together. Just like the old-time, isn’t it?]]></content>
      <tags>
        <tag>人生</tag>
        <tag>2019</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探深/浅拷贝]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%88%9D%E6%8E%A2%E6%B7%B1-%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管现在学习中并没有过多的涉及过多的深浅拷贝的内容，但区分深拷贝和浅拷贝会可以对java内存结构和运行方式有更深的了解。在初次尝试了使用深浅拷贝后，发现了clone()方法的水并不浅。再阅读了深度解析clone()实现深浅拷贝的博文后也发现了若要真正掌握深浅拷贝，并不是在于简简单单的识别深 还是 浅。而是要掌握其背后值传递和引用传递的原理。它们有时候还会共存。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;so，本次内容只记录到简单的深浅拷贝原理。等到鄙人水平有所提高时，再往下记录。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ps：以下提到的引用，若觉得生涩，都可以换成地址来理解整句话。java万物皆对象，但其实对象也就是一个地址值，说到底，java就只有值传递hahah首先这是一个定义好的对象 什么是浅拷贝？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果这个时候，要求将Soldier对象进行拷贝，也就是将Soldier整个复制一遍,不仅是自己，还将包含的成员复制一份,你将如何实现?这个时候我们不自觉地从拷贝联想到复制。并编写了如下代码.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行一系列输出测试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得到的结果&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们确实实现了对p1(Soldier)的复制，与其说是复制，更不如说是我们把p1所有存储的地址值都赋给p2，p1 p2除了本身的地址值不同，两个对象几乎拥有一模一样的地址指向。just like that~ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不仅是基本数据类型，就连引用数据类型，我们一并实现了值的传递和引用的传递。恭喜你，你实现了一个拷贝类型中的浅拷贝！！ 让我们来看一下浅拷贝的概念。 对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。 什么是深拷贝？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会产生疑惑，如果上述的拷贝为浅拷贝，那什么又叫深拷贝呢，难道还有另一种复制方式吗?答案是确实有，它的结构长这样。完全镜像却又毫无关联。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们看一下深拷贝的概念。 对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再次编写代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行一系列输出测试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到除了基本数据类型的age(返回为true)，其他的引用数据类型均创建了新的对象(返回为false)。 完全镜像却又毫无关联。 深浅拷贝的优缺点? 浅拷贝:相较于深拷贝效率高，且节省空间。但浅拷贝的结构会导致牵一发而动全身。只要任意一个拷贝对象（或原有对象）中的引用发生改变，所有对象均会受到影响。 深拷贝:修改任意一个对象，不会对其他对象产生影响，但它效率低且浪费空间(相较于浅拷贝)。 下一次，让我们进军clone()方法！！！]]></content>
      <categories>
        <category>后端方向</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bruce Wayne]]></title>
    <url>%2F2019%2F06%2F09%2FBruce-Wayne%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp; Such excessive workload, Bruce.&ensp;&ensp; It’s hard to believet that you still fantasy to make the promise for your mother after all things passed.&ensp;&ensp; Skill, strategy, or gear? Those are not the point which could support you walking to the end.&ensp;&ensp; It’s all about your heart, only in this way can we stand up over and over again, nomatter how stronger enemy was. when I get old, I won’t remember any fighting with Batman. But I will remember you, bruce.&ensp;&ensp; Your sprit and sacrifice,blood and tear–|————————————————––|————————————————––|————————————————––|————————————————––|————————————————––|————————————————––|————————————————–]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sham Chun]]></title>
    <url>%2F2019%2F05%2F18%2FSham-Chun%2F</url>
    <content type="text"><![CDATA[2019/5/18 12:35:55 First of all,thank Grammarly! It is you that let me know which I am enhancing in the right way This essay is from CET6 test in June 2016, which belongs to the part of the translation. Specification: 深圳是中国广东省一座新开发的城市.在改革开放之前，深圳不过是一个渔村，仅有三万多人。20世纪80年代，中国政府建立了深圳经济特区，作为实施社会主义经济的试验田。如今，深圳的人口已经超过1,000万，整个城市发生了巨大的变化。 到2014年，深圳的人均GDP已达25,000美元，相当于世界上一些发达国家的水平。就综合经济实力来看，深圳居于中国顶尖城市之列。由于其独特的地位，深圳也是国内外企业家创业的理想之地。 : Chun is a newly developing city in Guangdong province of China. Before the Reform and Opening started, Sham Chun just a fishing village, which only had over thirteen thousand people in there. In the1980s, the Chinese government established the Sham Chun economic region, which as the test field of socialism market of economic. Hitherto, the number of Sham Chun’s population has increased by over ten million, and the whole city has changed a lot. In 2014, the per-capita GDP of Sham Chun had arrived at twenty-five thousand dollars, which amount to the level in other developing countries in the world. In terms of the strength of integrated economic; Sham Chun is one of the elites city of China. As it owns unique status, Sham Chun is the paradise which attracts domestic and overseas entrepreneurs to start up their business. ps: if something is unique or special , please add an article]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[母亲节]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%AF%8D%E4%BA%B2%E8%8A%82%2F</url>
    <content type="text"><![CDATA[5月12日，母亲节。祝愿我的母亲能够一直过着健康，快乐的生活。母亲的对于生活的坚强，也是我一直学习的榜样。]]></content>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Let's translate something...]]></title>
    <url>%2F2019%2F04%2F14%2FLet-s-translate-something%2F</url>
    <content type="text"><![CDATA[2019/4/14 20:26:36 This essay is from CET6 test in June 2016, which belongs to the part of the translation. Specification: 中国的创新正以前所未有的速度蓬勃发展。为了在科学技术上尽快赶超掐他发达国家，中国近年来大幅度增加了研究开发资金。 中国的大学和研究所正在积极的开展创新研究，这些研究覆盖了从大数据到生化科学，从新能源到机器人等高科技领域。 他们还与各地的科技园合作，使创新成果商业化。 与此同时，无论在产品还是商业模式上，中国企业家也在努力的争做创新先锋，以适应国内外消费市场不断变化和增长的需求。 : The innovation of China is developing faster than ever before. To surpass World developed country quickly in science technology, China has drastically increased the fund of research recently. Chinese university and institution are actively conducting innovative research, those research covered a wide range of highly technical area from big data to biology chemistry, new resources to the robot and so on. What they have also cooperated with the science park in many places made the innovative product commercially. Meanwhile, It adopts the requires, which the domestic and foreign consumer market is changing that entrepreneur of China also make themselves better as the innovative charger, whatever on production or type of commercial.]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人形自走英汉词典养成(长期更)]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BA%BA%E5%BD%A2%E8%87%AA%E8%B5%B0%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8%E5%85%BB%E6%88%90%2F</url>
    <content type="text"><![CDATA[关于英语的学习，相信不论是应试注重的听力和语法，还是社会需求的对话和写作。（其实对话和写作其实就是应试的升华和综合应用）我们都需要词汇， 想得到单纯的高应试考试成绩还是综合全面的英语能力，都需要庞大的词汇量支撑。 词汇积累是一切的优良上层建筑建立的基础 周更 复习 对词汇学习的拓展 2019/3/28 14:34:06接下来的时间里记录的单词多半是六级的高频词汇。 domestic a. 国内的，家庭的，驯养的curb n. 约束，控制，边缘compromise n.妥协，折中 v.妥协，让步，（违背）contract v.签订，收缩，感染; n.合同，契约candidate n.候选人，应试者acquisition n.取得，获得，获得物absorb v.吸收，同化，全神贯注….arise 由…引起[Many questions alse arise in the cloning the dianosaurs]aspect n.方面，外观，朝向eternal a.永恒的，不变的vulnerable a.易受伤的，脆弱的 = weaknessestablish v.建立，证实，确实scale n.鳞片，规模，天平，比例，级别，音阶。 v.攀登，挂去鳞片severe a.严峻的，艰难的stereotype a.模式化思维，老一套 stereotype(v.) … 对…有成见massive a.巨量的，巨大的，大块的 (mass 块，堆，众多）rival n.竞争对手 v.与…为敌indicate v.表明，显示，表示，代表consume v.消耗，消费 be consumed with… …充满…contrast v.对比，对照 n.差异，不同；对照物crucial a.极其重要的，决定性的deposit v.将…存入,使沉积,放置 n.押金，定金acknowledge v.承认，告知，打招呼 acknowledge..as.. 认为..是..conflict v.矛盾，冲突 n.战斗，战争stuff n.物品，东西 v.填满装满 stuff后一般只接物，不接人tackle vt.对付,处理,与…交涉， v.阻截 n.器具，滑车 tackle down!abandon vt.放弃,抛弃 be abandoned oneself to … 沉溺于…/陷入…prospect n.前途，前景，可能性，景色 pro(forward)+spect(look)looking forwardremedy n.补救，药物 vt.纠正 beyong/without remedy 无药可救stimulate vt.刺激，促进，激发strengthen vt.加强，加固 [n]strength-&gt;[a]strong-&gt;[v]strengthenpatent a.专利的 n.专利 v.获得…专利peak n.顶峰，顶点 a.高峰的 v.到达顶峰 It’s peak time !principal a.重要的，首要的 n.(中小学)校长,资本，主角 [crucial]shed v.去除，摆脱，脱落，褪去； n.库房 shed tear/blood bloody hell!~prior a.在前的，优先的 prior to .. 在..之前chain n.链条,系列，连锁店 vt.束缚，拴住consequence n.结果后果 in consequence… 因此… ☆exhibit v.展示，表现 n.陈列品,物证！upgrade/update v.(使)升级,提高，改善vital a.必不可少的，极其重要的 curial.abuse v.虐待，滥用，辱骂 n.滥用…..circumstance n.情况，状况generate v.发生,产生 gene(基因)-&gt; gen-(生产)+er+ate(v.)medium a.中等的 n.媒介，手段profit - benefit n.利益，收益，好处 v.有益于value n.价值， +s “values”作”价值观”spot n.斑点，地点 vt.认出，发现yield vt.生产，产出 vt.屈服，头像 n.量产，收益alter v.(使)改变，修改 vt.修改enormous a.(尺寸，数量等)巨大的， e(ex,out)+ norm(normal)+ ous(..的) -enormous / gaint / massive institude n.学会，学院，研究所 vt.设置，设立ongoing a.任然在继续的oppose v.反对,与…较量status - states n.州，国家 v.声明,陈述 – n.身份，状态，地位thrive vi.兴荣，繁荣，成长 thrive thrive thrive !revenue n.收入，收益，税收 2019/3/31 1:04:57 光是了解了一主一谓就可以了吗？不不不，你还需要掌握(是掌握，不是熟悉！) 助动词 和 情态动词 助动词协助主要动词构成谓语的词叫助动词（Auxiliary Verb），也叫辅助动词。被协助的动词称作主要动词（Main Verb）。助动词用来构成时态和语态。 助动词具有语法意义，但没有词汇意义，不可单独作谓语。 情态动词情态动词（Modal verbs）本身有一定的词义，表示语气的单词。但是不能独立作谓语，只能和动词原形一起构成谓语。情态动词用在行为动词前，表示说话人对这一动作或状态的看法或主观设想。 情态动词虽然数量不多，但用途广泛 appropriate a.恰当的，适当的 vt.拨出(款项)供专用;私占，挪用associate vi.结交，交往 vt.联系，联想，与…有关association n.社团，协会;关系，关联 associate…with…cater v.为…提供食物，承包酒席； vt.迎合，投合cognitive a.认知的，(词根 cogn= know!!)curriculum n.课程 campus n.校园，校区embed v.(使)嵌入;使(思想)扎根于engage v.参加 vt. 吸引(某人的兴趣);雇佣(hire) vt.与…建立密切联系exert vt. 尽力，努力；施加(压力)！expertise n.专业知识，专长 What he’s bringing to us is the finanical expertise! 2019/4/1 19:08:59 搞懂”主系表”只需要1分钟，但要真正明白为什么会有”主系表”，就不但是时间的问题了。 numerous a.众多的，许多的reveal v.揭露，揭示，斜路; re(= off) + veal (= veil面纱)※advocate v.主张，拥护 n.拥护者，提倡者separate vi.分开，使分离;区分; vt.分离；分居distinguish v.辨别，区别 vt.使杰出，使扬名；听出，看清priority n.优先权，优先考虑的事track n.行踪，方向；轨道；曲子 v.跟踪truck n.货车alternative a.可供选择的，可代替的access vt.评价,评估 （calculate）attribute v.认为…属于;把…归结于 n.属于，特性consist - insist 由…组成 - 坚持emission n.(光，热，气等)散发，排放；排放物，散发物 emit(v.) -&gt; emission(n.) -&gt; exhaust emission 废气排放; 2019/4/3 21:10:13expense n.花销，消费imply vt.暗示，预示着invest v.投资，投入(时间/精力)；授予，赋予；notion n.概念，观念；意图，想法；overall a.全部的 n.工作连体服 adv.总的来说vehicle n.车辆；媒介，工具incentive n.刺激，鼓励，动力accelerate v.(使)加速，加快perceive vt.看待，理解；察觉，注意到perception n.认识，观念，看法；感知能力，洞察力assumption n.假设，假定；承担责任 hypothesisdemonstrate vt.论证，证明；显示；示范，演示essential a.必要的，必不可少；本质的，基础的 fundation n.基础recession n.衰退，萧条regulation n.规章，规则，管理，控制shrink v.收缩，变小，缩小staff n.全体员工,职工，手杖 vt. ….预备人员 清明放假三天，来检验一下自己的记忆能力吧-。- 2019/4/10 17:39:34equip vt.装备，使之能胜任 facility(装备)enterprise n.事业，单位，公司；进取心，上进心essence n.本质 essencial本质上的，重要的，基本的exaggerate v.夸大，夸张explore v.探讨，探究extend v.延展，扩张illegal a.非法的imperative a.紧急的 n.紧急的事indispensable a.必需的inquiry n.调查，查问;打听，询问;insurance n.保险，保险费用integrate v.合并，结合intelligence n.智力，智慧;情报literacy n.识字，读写能力;maintain v.保持，维持meanwhile ad.同时，期间minimum n.最小数 a. 最小的obvious a.显然的,显而易见的odd a.古怪的，奇怪的 weirdphenomenon n.现象pile n.堆 v.堆砌prosper prosperity n.兴旺protest n/v. 反对，抗议rare a.稀有的，罕见的 2019/4/20 15:13:50 rare n.后面，臀部; a.后方的，后部的 vt.抚养，饲养reject vt.婉拒，回绝 eject vt.放逐，逐出renew v.更新,重新开始,恢复resort v.采取， n.度假胜地segregation n.分离，隔离semester n.一学期，半年 (六个月)shortage n.缺陷， = defect = downsidespecialize vi.专门研究statistic n.统计数据，统计资料stem vi.源自，遏制submit vt.提交;主张；建议 vi.服从，屈从 = complytution n.学费，教学，讲课withdraw v.退出，撤回，取款obstract a.抽象的accuse vt.控告，指责adolescent n.青少年 a.青少年的assign v.分配，部署，确定calculate v.计算，核算 你肯定知道它的n喽， accurate a.精确地deadly a.致死的 ad.非常decorate vt.装饰，布置devote v.奉献，致力于energeic a.精力充沛的dynamic a.有力的 = robustexport v.出口，输出 n.出口物，输出物 2019/5/5 15:30:55prior prior adj.优先的，在前的，在先的 n.修道院院长 priority n.优先;优先权 [数]优先次序，优先考虑的事 prioritize v.安重要性排列;划分优先顺序;优先处理 priortization n.优先级；优先化；优化 join - engage engage in 多用于参与什么事情join in 多用于参与什么团体等 estimate - evaluate estimate多是书面语场合，evaluate正式场合用的多，而evaluate也有评价某人的意思。 connect - attach 两者都有连接的意思,但细分的话，attach多用于描述某物附属于另一个物体。而connect多指连个事务的连接，且具有抽象性质。 improve - enhance improve多指状态或性质上的深刻或重要改进,也可指自身能力的提高；enhance侧重指增加价值.魅力或声望等使人或物具有超乎寻常的吸引力. integrate - combine combine是联合的意思，侧重指某物某事与其他事物联成一体。而integrate也指联合，但更有整合的意思。侧重合并后这个整体. isolate - segment 两者都有切割的意思，都可以用。但isolate有名词形式表达孤独. appropriate(v. / a.) - adapt(v.) 都有恰当的，合适的 protest - oppose protest应用广，含义广泛，”反对”，隐含其正当性；而protest多指通过言语或行动表现出的强烈抗议. circumstance - status circumstance多指周围的情况或者某事发生时的情况,存在特指。而status 指一个人在政治,社会,经济,法律上的地位或者身份.]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《秋之回忆》真实场景·上（转载）]]></title>
    <url>%2F2018%2F09%2F14%2F%E3%80%8A%E7%A7%8B%E4%B9%8B%E5%9B%9E%E5%BF%86%E3%80%8B%E7%9C%9F%E5%AE%9E%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[我一直很喜欢的一款游戏，历代的场景均发生在日本，志仓千代丸社长对于游戏场景的取材也一直很有心，原博主的日本之旅也是围绕着秋回场景的地点来展开 【江之岛入口鸟居（芦鹿岛入口）】（出自MO4） 【龙恋の钟（星恋の丘）】现实世界中被称为“龙恋の钟”，Mo4里则是“星恋の丘”。 【J’S Garden餐厅（罗萨克）】接下来是位于的湘南海岸公园的J’S Garden餐厅，也就是游戏中的罗萨克的原型。在以前同好们的旅游贴图中，这家餐厅的名字是“SkyLark Garden”，现在已经改名。一路上类似的建筑其实也不少，或许这家也不一定就是罗萨克的原型 室内：【湘南海岸公园（Mo2开头伊波健及白河萤散步回家的沙滩）】 【江之岛站（浜咲站）】“江之岛电铁”（简称江之电，即游戏中的芦鹿电） 由于秋回系列到今天已经到了8，上面出现的只是无数场景的冰山一角，有时间再搬吧，期待下期吧还要赶C#~ 如果自己有机会去日本的话我也想拍啊啊啊啊啊！！！]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>秋之回忆</tag>
        <tag>霓虹</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真正的男儿不怕失败！]]></title>
    <url>%2F2018%2F08%2F26%2F%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%94%B7%E5%84%BF%E4%B8%8D%E6%80%95%E5%A4%B1%E8%B4%A5%EF%BC%81%2F</url>
    <content type="text"><![CDATA[输本，你是个真正的男子汉，对于活在现实的男儿们，有谁能一帆风顺。你的坚持和努力，比起输赢和奖杯，更让我们难以忘记。]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>2018</tag>
        <tag>soo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片走廊&放大镜]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%9B%BE%E7%89%87%E8%B5%B0%E5%BB%8A-%E6%94%BE%E5%A4%A7%E9%95%9C%2F</url>
    <content type="text"><![CDATA[大魏军营中关羽：你怎么平天下？曹：灭袁绍，平北方。怀柔江东孙家，驻军西凉，可谓中原一统太平。休养生息，不出十年，南蜀自然俯首称臣。曹操再三表意皇帝不可杀，否则各方诸侯都会以此为借口群起造反。届时乱世将难以终结，可惜谋事在人成事在天，最后历史还是如此的进行着，以至于到了三分天下从最初的汉室垂危黄巾起义到最后天下归一，六十年，国号不为蜀，不为魏，更不为吴，而是晋。生逢乱世，有人成为了一代名将，一代谋士，一代君王；有人看淡了成败，有人认清了现实，有人年少成名，有人大器晚成，有人含恨而终，有人英勇赴死。而作为历史的见证者，我们看到的则是“滚滚长江东逝水,浪花淘尽英雄” 咳咳，回到2018， 距离返校还有不到十天的时间，抓紧多练习一些JS方面的小组件，原来只是想着练习图片走廊，但后来发现图片走廊一般都是搭配放大镜功能出现的，便一并写了，过程不算平坦。 关于图片走廊和放大镜 这次练习中，使用了queryselector的方法抓取元素，就效率而言虽没有getElementby..函数高，但胜在方便。也更加深入学习了DOM与BOM中的getAttribute与setAttribute，各种距离相关的属性clientX/clientY，getBoundingClientRect()，加深了元素与浏览器之间互动的编程理解。 保存过程中有一点十分有趣，前半部分图片走廊是利用循环加上闭包给元素绑定事件，而后半段放大镜则是利用addEventListener事件监听的功能进行事件绑定。面对多种多样的编程方式，都应多加涉猎与练习思考。 不断地练习组件，但还是把它们放在一起，不然徒有一堆部件而不成完品。就想测试中既有单元测试也有集成测试一样。我把之前的轮播图和这次的图片走廊&amp;放大镜放在一起进行编写，发现变量的命名是个大问题。论坛社区中一直强调的代码规范性第一次实打实的出现在了眼前，还需多加练习。 4.完成组件如图 正题↓HTML部分 一个主盒子content,包含着上部分pic，下部分list。上部分展示大图，下部分图片走廊。cover是选择放大区域，而display是展现放大区域。 &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;pic&quot;&gt; &lt;img src=&quot;img/clothes1.jpg&quot; alt=&quot;11&quot; class=&quot;Big&quot;&gt; &lt;div class=&quot;cover&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li&gt;&lt;img src=&quot;img/clothes1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/clothes2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/clothes3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/clothes4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/clothes5.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;display&quot;&gt;&lt;/div&gt; &lt;/div&gt; CSS部分 css部分没有多少新东西，就是div+css常规写法，就是图片走廊部分list采用flex弹性盒模型，还有justify-content属性。让布局省力了些。 *{ margin: 0; padding: 0; text-decoration: none; list-style-type: none; } .content{ position: relative; width: 400px; height: 480px; margin: 60px auto; border: 1px solid orangered; } .Big{ width: 400px; height: 400px; } .list{ display: flex; margin-top: 5px; align-items: center; justify-content: space-around; height: 80px; } .list img{ width: 50px; height: 50px; display: block; } .list .active{ border: solid royalblue; } .cover{ position: absolute; top: 0; left: 0; opacity: 0.3; width: 100px; height: 100px; background: blue; display: none; } .display{ position: absolute; top: 0; left: 400px; width: 400px; height: 400px; background-image: url(../img/clothes1.jpg); background-size: 400%; //思考 display: none; } JS部分ps：由于代码思路并不是完全自顶向下，譬如一些函数调用时写到第80行才回到第25行进行调用，所以我尽量注解，我认为阅读代码也是一项技能，像电路板一样，时而一鼓作气，时而峰回路转，哈哈。 抓取元素 var list = document.querySelector(&apos;.list&apos;), imgs = list.querySelectorAll(&apos;img&apos;), Big = document.querySelector(&apos;.Big&apos;), pic = document.querySelector(&apos;.pic&apos;), cover = document.querySelector(&apos;.cover&apos;), display = document.querySelector(&apos;.display&apos;), index = 0; //square（）函数将用到 开始抓取小图的src，并把小图的src设置给大图 showPic(whichPic)中的whichPic是小图中的某个，小图并不是单一个，而是一个数组，我们要假设一个形参 function showPic(whichPic){ var small = whichPic.getAttribute(&apos;src&apos;); Big.setAttribute(&apos;src&apos;,small); display.style.backgroundImage = &apos;url(&apos;+ small +&apos;)&apos;; //这行代码的作用是在后面display放大区域的呈现 } 开始实现鼠标放置在指定小图，指定的小图实现border(其实可以加的不止是border，你也可以参照自己的想法加很多属性) function square(){ for(var i = 0;i&lt;imgs.length;i++){ if(imgs[i].className = &apos;active&apos;){ imgs[i].className = &apos;&apos;; } } imgs[index].className = &apos;active&apos;; //注意此行代码的位置，不要写错.这里的index如何放置也值得思考。 } 这里我们已经将两大函数功能完成，剩下的是进行事件绑定 这里使用了立即执行函数也就是闭包(很多时候我们不用闭包功能依旧能实现，但错误的数字循环会让以后的程序拓展性堵死，不可取。要养成习惯) 我们把其中i的值赋给了index，因为0 1 2 3 4这样的计时走法完美符合square()函数的规则。我们指到哪个，哪个就添加active 这里的showPic(this)，我们把指定的小图(this)，传给showPic() for(var i = 0;i&lt;imgs.length;i++){ (function(i){ imgs[i].onmouseover = function(){ showPic(this); index = i; square(); } })(i); //这里的括号若不熟悉需要多多观察 } ps:到这里，前半部分的功能算是结束了，下半部分则是运用事件监听来让cover随着鼠标移动，随即让放大区域display跟着移动。这里我搜索了很多，没办法，很多BOM DOM都需要在实践中学习。 我们抓取pic，并给它进行事件监听，这里参数e也需要多多思考 我们选取了 client X ,clientY 这两个是鼠标距离浏览器左上角的top值和left值 而getBoundingClientRect().left/top则是选取了元素距离浏览器左上角的top值和left值 我们想要cover随着移动，无非就是让cover的top值和left值随着鼠标的移动而产生变化。而cover的top值和left值就需要一个减法来实现 而这个值就是clientX减去getBoundingClientRect().left 为什么要这样，为什么要还要减50，如图所示(其实这里还是画的不太严谨，B指向的应该是cover小块的左上角,A指向大图的左上角) 垂直的Y轴同理，操作一致。 我们还要让cover在pic框内不出去，要设定四个if语句 pic.addEventListener(&apos;mousemove&apos;,function(e){ cover.style.display = &apos;block&apos;; //放置即出现 display.style.display = &apos;block&apos;; //放置即出现 var x = e.clientX, y = e.clientY, cx = pic.getBoundingClientRect().left, cy = pic.getBoundingClientRect().top, tx = x - cx - 50, ty = y - cy - 50; if(tx&lt;0){ tx = 0; } if(ty&lt;0){ ty = 0; } if(tx&gt;300){ tx = 300; } if(ty&gt;300){ ty = 300; } cover.style.left = tx + &apos;px&apos;; //取值 cover.style.top = ty + &apos;px&apos;; //取值 display.style.backgroundPosition = tx/300*100 + &apos;%&apos; + ty/300 *100 + &apos;%&apos;; //让display内的背景图放大，需要思考 }) 我们还需要让鼠标移出大图时cover和display消失 pic.addEventListener(&apos;mouseout&apos;,function(){ cover.style.display = &apos;none&apos;; display.style.display = &apos;none&apos;; }) 好了，到这里整个部件就完成了，不多不少。 这两个月，快接近尾声，战友们都按故旧班的完成着自己的任务，甚是开心。让人越来越期待出去的日子了。 完整代码在此–&gt;GITHUB]]></content>
      <categories>
        <category>前端方面</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>js</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单易学的轮播图(面向过程函数式)]]></title>
    <url>%2F2018%2F08%2F07%2F%E7%AE%80%E5%8D%95%E6%98%93%E5%AD%A6%E7%9A%84%E8%BD%AE%E6%92%AD%E5%9B%BE-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[不知不觉已到了八月，不知道说什么，冲冲冲！ 原生的js小模块可写的还有很多，先从轮播图开始吧 在首次尝试抄写刘彦佐前辈博客中的Js轮播图后，大致了解了 HTML与 CSS的流程，也通过博客中的JS部分学习了几个重要的api（或者叫函数function），列如setTimeOut(),clearTimeOut(),setInterval(),clearInterval(),parseInt()…. 这是第二次练习轮播图，在改变偏移值实现轮播的基础上再加上一些自己的东西，也希望自己尽量少的查看源码来实现，当然，第二次肯定还是会有细节出现遗漏的情况，只是希望能少些。 这个轮播图代码刘彦佐前辈本人是这样说的 讲的是用面向过程函数式编程去实现，相对于面向对象设计模式，代码难免会显得臃肿冗余。但没有面向对象的抽象却很适合新手理解与学习 这句话我也能大概通过另一个轮播图实现感觉到，希望在后面的学习实践中更加理性的认识和理解这句话。 感谢刘彦佐前辈的分享 写完我觉得有必要加上过渡，虽然我还不会,最后的”闭包”环节也有待理解 该轮播图原理如下 正题↓HTML部分 1.先使用一个母盒container 2.图片盒list-&gt;imgx( x为pictures数目 ) 3.按钮盒buttons-&gt;spany( y为具体buttons数目 ) 4.箭头盒arrow 左右两个 5.list的left属性是轮播的关键，它的偏移值(value)会让container盒子里的img发生变化，从而实现切换 6.buttons里的span带有的类名为”on”的属性,是让按钮随着轮播进行变换的关键 &lt;div class=&quot;container&quot; id=&quot;container&quot;&gt; &lt;div class=&quot;list&quot; id=&quot;list&quot; style=&quot;left: 0px&quot;&gt; &lt;img src=&quot;img/1.jpg&quot; alt=&quot;1&quot;&gt; &lt;img src=&quot;img/2.jpg&quot; alt=&quot;2&quot;&gt; &lt;img src=&quot;img/3.jpg&quot; alt=&quot;3&quot;&gt; &lt;img src=&quot;img/4.jpg&quot; alt=&quot;4&quot;&gt; &lt;img src=&quot;img/5.jpg&quot; alt=&quot;5&quot;&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot; id=&quot;buttons&quot;&gt; &lt;span index = &quot;1&quot; class= &quot;on&quot;&gt;&lt;/span&gt; &lt;span index = &quot;2&quot;;&gt;&lt;/span&gt; &lt;span index = &quot;3&quot;;&gt;&lt;/span&gt; &lt;span index = &quot;4&quot;;&gt;&lt;/span&gt; &lt;span index = &quot;5&quot;;&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;arrow&quot; id=&quot;prev&quot;&gt;&amp;lt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;arrow&quot; id=&quot;next&quot;&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt; CSS部分 1.建立初始化CSS 2.主盒子container的宽高取决于你要选取的大小 3.为了使list的核心属性left能够生效，需要给list添加绝对定位,自然父元素container也需要添加相对定位* 4.当list受到container定位关系的管制后，我们还需要为container添加超出隐藏 5.从轮播图的设计来看，箭头arrow和button按钮都应该在图的上方，因为我们需要点击它们来对图进行操作， 所以 list(z-index:1) arrow(z-index:2) buttons(z-index:2) 6.因list已添加了绝对定位和层级，所以后续的标签想要显现出来不仅需要z-index，还需要进行脱离文档流的设置 (脱离文档流采用浮动和定位皆可) 7.介于是练习阶段并没有专业的UI设计，关于按钮span和arrow箭头的设计取决于开发者的个人审美水平和取向，应 多加涉及和思考&amp;尝试 8.箭头的设计理念为鼠标放在轮播区域即显示，放在轮播区外即隐藏,so……u know how to deal with this! *{ margin: 0; padding: 0; text-decoration: none; list-style-type: none; } .container{ position: relative; width: 1000px; height: 400px; margin: 100px auto 0 auto; border: 2px solid #000; overflow: hidden; } .list{ position: absolute; width: 5000px; height: 400px; z-index: 1; } .list img{ width: 1000px; height: 400px; float: left; } .buttons{ z-index: 2; position: absolute; width: 300px; height: 50px; bottom: 0; left: 346px; } .buttons span{ float: left; width: 40px; height: 30px; margin-left: 14px; background-color: #000; border-radius: 50%; border: 1px solid #fff; cursor: pointer; } .buttons .on{ background-color: orangered; } .arrow{ display: none; z-index: 2; position: absolute; width: 80px; height: 80px; font-size: 105px; font-weight: bold; text-align: center; line-height: 65px; top: 160px; color: #fff; background: rgba(0, 0, 0, 0.3); } .arrow:hover{ background: rgba(0, 0, 0, 0.7); } .container:hover .arrow{ display: block; } #next{ right: 0; } 到这里该轮播图的页面部分已完成，接下来重点练习环节 JS部分 1.由于抓取dom元素在编写Js中非常频繁，所以我们将document.getElementById()进行封装 /*封装函数 */ function ById(id){ return typeof(id)? document.getElementById(id):&apos;id&apos;; } function ByTagName(tagName){ return typeof(tagName)? document.getElementsByTagName(tagName):&apos;tagName&apos; } 2.抓取DOM元素 var container = ById(&apos;container&apos;), list = ById(&apos;list&apos;), prev = ById(&apos;prev&apos;), next = ById(&apos;next&apos;), timer, //后续会用到 index = 1;//后续会用到 var buttons = ByTagName(&apos;span&apos;); 3.进行左右箭头切换图片的功能编写 1)这里parseInt()获取的值是一个整数,而list.style.left获取的是相对于左边的距离 2)style.left获取的是字符串，需要用parseInt()取整转化为数字 3)不要想当然的认为prev向前一张图就添加负数，next同理.增加偏移值是作用在list上 4)绑定左右箭头事件 /* 偏移值变换*/ function mov(value){ var newLeft = parseInt(list.style.left) + value; list.style.left = newLeft + &apos;px&apos;; } prev.onclick = function(){ mov(1000); } next.onclick = function(){ mov(-1000); } 4.first与last的回滚 1)在这段代码中,偏移值小于-4000图片就会出现空白,大于0也是,因为我们需要做一个简单的判断 2)但要注意，这个判断是要放在 mov函数里面的，逻辑问题** if(newLeft&lt;-4000){ list.style.left = 0 + &apos;px&apos;; } if(newLeft&gt;0){ list.style.left = -4000 + &apos;px&apos;; } 5.自动轮播函数 1)利用库函数定时器构建自动轮播, function play(){ timer = setInterval(function(){ next.onclick() },2000) } play(); 6.清除轮播 1)clearInterval()方法的参数必须是由setInterval()返回的ID值** function stop(){ clearInterval(timer); } container.onmouseover = stop; container.onmouseout = play; 7.圆点响应 1)buttonsShow函数让每次更换图片下面的圆点都会全部变黑，然后通过index的值让特定的圆点变色，顺序搞清楚很重要 2) buttons[index-1].className = ‘on’; 这段代码写在for循环里也可以，外面也可以.不影响功能，但里面却影响了性能 function buttonsShow(){ for(var i = 0;i&lt; buttons.length;i++){ if(buttons[i].className = &apos;on&apos;){ buttons[i].className = &apos;&apos;; } }buttons[index-1].className = &apos;on&apos;; } 3)由于引入了圆点，index. prev和next的箭头事件需要增加内容，分别改为: prev.onclick = function(){ index -=1; if(index&lt;1){ //圆点和图一样，first和last需要进行判断来达到回滚 index = 5; } buttonsShow(); mov(1000); } next.onclick = function(){ index+=1; if(index&gt;5){ //圆点和图一样，first和last需要进行判断来达到回滚 index = 1; } buttonsShow(); mov(-1000); } 到这里为止，我们已经完成了自动轮播，左右箭头播放。圆点虽然能够能够根据图片的变换进行响应变色，但圆点本身还是不能进行点击选取播放。下面的代码就完成了该功能。 8.这里使用了闭包，我暂时还没有搞太清楚。 for (var i = 0; i &lt; buttons.length; i++) { // 这里使用的是立即执行函数， (function(i) { buttons[i].onclick = function() { var clickIndex = parseInt(this.getAttribute(&apos;index&apos;)); console.log(clickIndex); var value = 1000 * (index - clickIndex); mov(value); index = clickIndex; buttonsShow(); } })(i) } 大功告成，一个完整的轮播图就这样完成了。我知道这不短，但是按照步骤一点点编写，一边写一遍思考。一遍不行就两遍，两遍不行就三遍。它迟早是你的。 最后如果觉得分离开的代码不够，在我的github上有完整代码GITHUB喜欢的话，给个star吧！]]></content>
      <categories>
        <category>前端方面</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>js</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next day]]></title>
    <url>%2F2018%2F07%2F10%2Fnext-day%2F</url>
    <content type="text"><![CDATA[完成Hexo博客的网址图标ICO 完成Hexo博客的各种连接]]></content>
  </entry>
  <entry>
    <title><![CDATA[当然我不是在瞎扯淡！]]></title>
    <url>%2F2018%2F07%2F08%2F%E5%BD%93%E7%84%B6%E6%88%91%E4%B8%8D%E6%98%AF%E5%9C%A8%E7%9E%8E%E6%89%AF%E6%B7%A1%EF%BC%81%2F</url>
    <content type="text"><![CDATA[忙碌的这两个月随着时间的推移，再次回到校园已是秋季。 当然我一直喜欢秋天和冬天，即使是忙碌的秋季。燥热会让我难以集中。 由于事情启动的有些仓促，所以这两个月对我和两个战友都非常难熬，不过相信他们也能坚持下去就是了。这都坚持不下来还打个P！淦 # English jQuery bootstrap 原生JS #关于English阅读《野性的呼唤》,并把它完成，并考虑每天都抽出一点时间学习它（movie || Internet || terms），虽然这并不简单。 这个应该2018年底就可以得到检验 “读书百遍、其义自见”，放在英文阅读上也是一样。当我们保持一个比较好的英文阅读习惯之后，我们会发现越读越容易。虽然前期会觉得有点痛苦，并且需要刻意来完成，但只要扛过了习惯建立的前期时间，后面就很容易了。 #关于jQuery&amp;Bootstarp完成jQuery实战&amp;bootstrap实战两本书籍。 对我来说这是蛮具有挑战的，尤其是加入了英语之后。但我相信能够合理安排时间加上专注力的话这并不是难事。 #关于原生JS没什么可说的，在Jquery和bootstrap的环节中我会练习到到它并翻阅书籍。 框架是给成手用来提高开发效率的，并不是给生手用来快速上手的。框架是在基本原理的基础上进行封装，如果不了解基本原理，使用框架也并不简单。 #希望一切都够顺利，当然其实也就是希望我们自己能够坚持下去 Ps:MarkdownPad 2 真是好~ :) 2018-7-8]]></content>
  </entry>
</search>
